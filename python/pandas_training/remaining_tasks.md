## Задание 31

**Используйте метод `corr` для вычисления корреляции между числовыми столбцами DataFrame.**

Для чего это нужно: Корреляционный анализ помогает выявить взаимосвязи между переменными, что важно для понимания данных и выбора признаков для моделирования.

Методы и функции для изучения:
* `DataFrame.corr()` - вычисляет попарную корреляцию между столбцами

```python
# Введите ваш код здесь
correlation_matrix = df.select_dtypes(include=['number']).corr()

# Визуализируем корреляционную матрицу
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5)
plt.title('Корреляционная матрица числовых признаков')
plt.show()
```

## Задание 32

**Создайте новый столбец 'Title', извлекая титул из имени пассажира (столбец 'Name').**

Для чего это нужно: Извлечение информации из текстовых данных может дать дополнительные полезные признаки для анализа и моделирования.

Методы и функции для изучения:
* `Series.str.extract()` - извлекает части строк с помощью регулярных выражений

```python
# Введите ваш код здесь
# Извлекаем титул из имени (находится между запятой и точкой)
df['Title'] = df['Name'].str.extract(' ([A-Za-z]+)\.')

# Посмотрим на уникальные титулы
unique_titles = df['Title'].unique()
print(unique_titles)

# Посмотрим на распределение титулов
df['Title'].value_counts()
```

## Задание 33

**Создайте сводную статистику, показывающую процент выживаемости по признаку 'Title'.**

Для чего это нужно: Анализ связи между выживаемостью и социальным статусом (определяемым титулом) может дать интересные инсайты о приоритетности спасения во время катастрофы.

Методы и функции для изучения:
* `DataFrame.groupby()` - группирует данные по указанному столбцу
* `Series.mean()` и множитель для получения процентов

```python
# Введите ваш код здесь
survival_rate_by_title = df.groupby('Title')['Survived'].mean() * 100

# Сортируем результаты по убыванию показателя выживаемости
survival_rate_by_title = survival_rate_by_title.sort_values(ascending=False)
survival_rate_by_title
```

## Задание 34

**Используя метод `pd.cut`, разделите пассажиров на группы по стоимости билета (столбец 'Fare').**

Для чего это нужно: Группировка числовых данных в категории может упростить анализ взаимосвязей, особенно если данные имеют неравномерное распределение.

Методы и функции для изучения:
* `pd.cut()` - разбивает непрерывные данные на бины
* `Series.value_counts()` - подсчитывает частоту вхождения значений

```python
# Введите ваш код здесь
# Создаем бины для разных ценовых категорий
fare_bins = [0, 20, 50, 100, 600]
fare_labels = ['Низкая', 'Средняя', 'Высокая', 'Очень высокая']

df['Fare_Category'] = pd.cut(df['Fare'], bins=fare_bins, labels=fare_labels)

# Показываем распределение по ценовым категориям
fare_distribution = df['Fare_Category'].value_counts().sort_index()
fare_distribution
```

## Задание 35

**Рассчитайте процент выживаемости в зависимости от ценовой категории билета.**

Для чего это нужно: Анализ зависимости выживаемости от стоимости билета может указать на связь между социально-экономическим статусом и шансами на спасение.

Методы и функции для изучения:
* `DataFrame.groupby()` - группирует данные по указанному столбцу
* `Series.mean()` - вычисляет среднее значение

```python
# Введите ваш код здесь
survival_by_fare = df.groupby('Fare_Category')['Survived'].mean() * 100
survival_by_fare

# Визуализируем результаты
plt.figure(figsize=(10, 6))
sns.barplot(x=survival_by_fare.index, y=survival_by_fare.values)
plt.xlabel('Ценовая категория')
plt.ylabel('Процент выживших')
plt.title('Выживаемость по ценовой категории билета')
plt.show()
```

## Задание 36

**Используя метод `melt`, преобразуйте столбцы 'Age' и 'Fare' из широкого формата в длинный.**

Для чего это нужно: Преобразование данных из широкого формата в длинный (операция unpivot) часто необходимо для определенных видов анализа и визуализации, особенно при работе с библиотеками визуализации.

Методы и функции для изучения:
* `pd.melt()` - преобразует DataFrame из широкого формата в длинный

```python
# Введите ваш код здесь
# Выбираем столбцы для преобразования и идентификаторы
id_vars = ['PassengerId', 'Survived', 'Name']
value_vars = ['Age', 'Fare']

# Преобразуем данные из широкого формата в длинный
melted_df = pd.melt(df, id_vars=id_vars, value_vars=value_vars, 
                    var_name='Variable', value_name='Value')

# Выводим первые строки преобразованных данных
melted_df.head(10)
```

## Задание 37

**Проанализируйте, как часто встречаются различные порты отправления (столбец 'Embarked').**

Для чего это нужно: Изучение распределения категориальных переменных помогает понять структуру данных и может дать представление о важных аспектах исследуемого явления.

Методы и функции для изучения:
* `Series.value_counts()` - подсчитывает частоту вхождения каждого значения
* `Series.plot.pie()` - создает круговую диаграмму

```python
# Введите ваш код здесь
embarked_counts = df['Embarked'].value_counts()

# Создаем словарь для расшифровки портов
port_names = {'C': 'Шербур', 'Q': 'Квинстаун', 'S': 'Саутгемптон'}

# Заменяем коды портов на их названия
embarked_counts.index = [port_names.get(port, port) for port in embarked_counts.index]

# Визуализируем результаты
plt.figure(figsize=(8, 8))
embarked_counts.plot.pie(autopct='%1.1f%%', startangle=90, 
                       colors=sns.color_palette('pastel'))
plt.title('Распределение пассажиров по портам отправления')
plt.ylabel('')
plt.show()
```

## Задание 38

**Используя метод `fillna`, заполните пропущенные значения в столбце 'Embarked' наиболее часто встречающимся значением.**

Для чего это нужно: Заполнение пропущенных значений наиболее частым значением (модой) - один из методов обработки пропусков, который может быть полезен для категориальных переменных.

Методы и функции для изучения:
* `Series.value_counts()` - подсчитывает частоту значений
* `Series.fillna()` - заполняет пропущенные значения

```python
# Введите ваш код здесь
# Сначала посмотрим, сколько пропущенных значений в столбце 'Embarked'
print(f"Количество пропущенных значений в 'Embarked': {df['Embarked'].isnull().sum()}")

# Находим наиболее часто встречающееся значение (моду)
most_common_port = df['Embarked'].mode()[0]
print(f"Наиболее частый порт отправления: {most_common_port}")

# Заполняем пропущенные значения
df['Embarked'] = df['Embarked'].fillna(most_common_port)

# Проверяем, остались ли пропущенные значения
print(f"Количество пропущенных значений после заполнения: {df['Embarked'].isnull().sum()}")
```

## Задание 39

**Преобразуйте категориальные переменные 'Sex' и 'Embarked' с помощью метода `get_dummies`.**

Для чего это нужно: One-hot кодирование категориальных переменных необходимо для использования их в большинстве алгоритмов машинного обучения, которые работают только с числовыми данными.

Методы и функции для изучения:
* `pd.get_dummies()` - преобразует категориальные переменные в бинарные столбцы

```python
# Введите ваш код здесь
# Применяем one-hot кодирование к столбцам 'Sex' и 'Embarked'
dummies_sex = pd.get_dummies(df['Sex'], prefix='Sex')
dummies_embarked = pd.get_dummies(df['Embarked'], prefix='Embarked')

# Объединяем полученные столбцы с исходным DataFrame
df_with_dummies = pd.concat([df, dummies_sex, dummies_embarked], axis=1)

# Выводим первые строки нового DataFrame
df_with_dummies.head()
```

## Задание 40

**Создайте новый DataFrame, содержащий только необходимые для моделирования признаки, и сохраните его в CSV-файл.**

Для чего это нужно: После предобработки данных часто требуется сохранить только необходимые признаки для дальнейшего моделирования, что уменьшает размер файла и упрощает анализ.

Методы и функции для изучения:
* `DataFrame.drop()` - удаляет указанные столбцы
* `DataFrame.to_csv()` - сохраняет DataFrame в CSV-файл

```python
# Введите ваш код здесь
# Выбираем столбцы для итогового DataFrame
features_to_keep = ['PassengerId', 'Survived', 'Pclass', 'Sex_numeric', 
                     'Age', 'SibSp', 'Parch', 'Fare', 'Embarked',
                     'FamilySize', 'IsAlone']

# Создаем новый DataFrame только с нужными признаками
modeling_df = df[features_to_keep].copy()

# Проверяем, остались ли пропущенные значения
print(modeling_df.isnull().sum())

# Сохраняем DataFrame в CSV-файл
modeling_df.to_csv('../datasets/titanic/processed_data.csv', index=False)

print("DataFrame успешно сохранен в CSV-файл.")
modeling_df.head()
```
